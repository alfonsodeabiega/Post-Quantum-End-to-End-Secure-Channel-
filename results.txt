.\proverif.exe pqhandshake.pv


Linear part: No equation.
Convergent part:
decaps(dk(ek),encap_c(ek,r)) = encap_k(ek,r)
Completing equations...
Completed equations:
decaps(dk(ek),encap_c(ek,r)) = encap_k(ek,r)
Process 0 (that is, the initial process):
(
    {1}!
    {2}in(net, x: bitstring);
    {3}out(net, x)
) | (
    {4}let id1: bitstring = ID1 in
    {5}let id2: bitstring = ID2 in
    {6}event c1_start(id1,id2);
    {7}new ek1: bitstring;
    {8}let dk1: bitstring = dk(ek1) in
    {9}new n1: bitstring;
    {10}let b1: bitstring = B1(CTX,INIT,id1,id2,n1,ek1) in
    {11}let sig1: bitstring = sign(skD1,H(b1)) in
    {12}out(net, M1(id1,id2,n1,ek1,sig1));
    {13}in(net, M2(id1r: bitstring,id2r: bitstring,n1r: bitstring,n2: bitstring,ek2: bitstring,sig2: bitstring));
    {14}if (id1r = id1) then
    {15}if (id2r = id2) then
    {16}if (n1r = n1) then
    {17}let b2: bitstring = B2(CTX,RESP,id1,id2,n1,n2,ek1,ek2) in
    {18}if (sig2 = sign(skD2,H(b2))) then
    {19}event c1_auth(id1,id2,n1,n2,ek1,ek2);
    {20}new r12: bitstring;
    {21}let c12: bitstring = encap_c(ek2,r12) in
    {22}let k12: bitstring = encap_k(ek2,r12) in
    {23}out(net, M3(c12));
    {24}in(net, M4(c21: bitstring));
    {25}let k21: bitstring = decaps(dk1,c21) in
    {26}let th: bitstring = TH(id1,id2,n1,n2,ek1,ek2,c12,c21) in
    {27}let ke2e: bitstring = KDF(k12,k21,th) in
    {28}let kcI: bitstring = mac(ke2e,H(tag(th,KCI))) in
    {29}out(net, M5(kcI));
    {30}in(net, M6(kcR: bitstring));
    {31}let expR: bitstring = mac(ke2e,H(tag(th,KCR))) in
    {32}if (kcR = expR) then
    {33}event session_key(ke2e);
    {34}event c1_end(id1,id2,n1,n2,ek1,ek2,ke2e)
) | (
    {35}let id1_1: bitstring = ID1 in
    {36}let id2_1: bitstring = ID2 in
    {37}event c2_start(id1_1,id2_1);
    {38}in(net, M1(id1r_1: bitstring,id2r_1: bitstring,n1_1: bitstring,ek1_1: bitstring,sig1_1: bitstring));
    {39}if (id1r_1 = id1_1) then
    {40}if (id2r_1 = id2_1) then
    {41}let b1_1: bitstring = B1(CTX,INIT,id1_1,id2_1,n1_1,ek1_1) in
    {42}if (sig1_1 = sign(skD1,H(b1_1))) then
    {43}new ek2_1: bitstring;
    {44}let dk2: bitstring = dk(ek2_1) in
    {45}new n2_1: bitstring;
    {46}let b2_1: bitstring = B2(CTX,RESP,id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1) in
    {47}let sig2_1: bitstring = sign(skD2,H(b2_1)) in
    {48}out(net, M2(id1_1,id2_1,n1_1,n2_1,ek2_1,sig2_1));
    {49}event c2_auth(id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1);
    {50}in(net, M3(c12_1: bitstring));
    {51}let k12_1: bitstring = decaps(dk2,c12_1) in
    {52}new r21: bitstring;
    {53}let c21_1: bitstring = encap_c(ek1_1,r21) in
    {54}let k21_1: bitstring = encap_k(ek1_1,r21) in
    {55}out(net, M4(c21_1));
    {56}let th_1: bitstring = TH(id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1,c12_1,c21_1) in
    {57}let ke2e_1: bitstring = KDF(k12_1,k21_1,th_1) in
    {58}in(net, M5(kcI_1: bitstring));
    {59}let expI: bitstring = mac(ke2e_1,H(tag(th_1,KCI))) in
    {60}if (kcI_1 = expI) then
    {61}let kcR_1: bitstring = mac(ke2e_1,H(tag(th_1,KCR))) in
    {62}out(net, M6(kcR_1));
    {63}event session_key(ke2e_1);
    {64}event c2_end(id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1,ke2e_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}!
    {2}in(net, x: bitstring);
    {3}out(net, x)
) | (
    {5}let id2: bitstring = ID2 in
    {4}let id1: bitstring = ID1 in
    {6}event c1_start(id1,id2);
    {7}new ek1: bitstring;
    {9}new n1: bitstring;
    {10}let b1: bitstring = B1(CTX,INIT,id1,id2,n1,ek1) in
    {11}let sig1: bitstring = sign(skD1,H(b1)) in
    {12}out(net, M1(id1,id2,n1,ek1,sig1));
    {13}in(net, M2(id1r: bitstring,id2r: bitstring,n1r: bitstring,n2: bitstring,ek2: bitstring,sig2: bitstring));
    {14}if (id1r = id1) then
    {15}if (id2r = id2) then
    {16}if (n1r = n1) then
    {17}let b2: bitstring = B2(CTX,RESP,id1,id2,n1,n2,ek1,ek2) in
    {18}if (sig2 = sign(skD2,H(b2))) then
    {19}event c1_auth(id1,id2,n1,n2,ek1,ek2);
    {20}new r12: bitstring;
    {21}let c12: bitstring = encap_c(ek2,r12) in
    {23}out(net, M3(c12));
    {24}in(net, M4(c21: bitstring));
    {26}let th: bitstring = TH(id1,id2,n1,n2,ek1,ek2,c12,c21) in
    {8}let dk1: bitstring = dk(ek1) in
    {25}let k21: bitstring = decaps(dk1,c21) in
    {22}let k12: bitstring = encap_k(ek2,r12) in
    {27}let ke2e: bitstring = KDF(k12,k21,th) in
    {28}let kcI: bitstring = mac(ke2e,H(tag(th,KCI))) in
    {29}out(net, M5(kcI));
    {30}in(net, M6(kcR: bitstring));
    {31}let expR: bitstring = mac(ke2e,H(tag(th,KCR))) in
    {32}if (kcR = expR) then
    {33}event session_key(ke2e);
    {34}event c1_end(id1,id2,n1,n2,ek1,ek2,ke2e)
) | (
    {36}let id2_1: bitstring = ID2 in
    {35}let id1_1: bitstring = ID1 in
    {37}event c2_start(id1_1,id2_1);
    {38}in(net, M1(id1r_1: bitstring,id2r_1: bitstring,n1_1: bitstring,ek1_1: bitstring,sig1_1: bitstring));
    {39}if (id1r_1 = id1_1) then
    {40}if (id2r_1 = id2_1) then
    {41}let b1_1: bitstring = B1(CTX,INIT,id1_1,id2_1,n1_1,ek1_1) in
    {42}if (sig1_1 = sign(skD1,H(b1_1))) then
    {43}new ek2_1: bitstring;
    {45}new n2_1: bitstring;
    {46}let b2_1: bitstring = B2(CTX,RESP,id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1) in
    {47}let sig2_1: bitstring = sign(skD2,H(b2_1)) in
    {48}out(net, M2(id1_1,id2_1,n1_1,n2_1,ek2_1,sig2_1));
    {49}event c2_auth(id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1);
    {50}in(net, M3(c12_1: bitstring));
    {52}new r21: bitstring;
    {53}let c21_1: bitstring = encap_c(ek1_1,r21) in
    {55}out(net, M4(c21_1));
    {58}in(net, M5(kcI_1: bitstring));
    {56}let th_1: bitstring = TH(id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1,c12_1,c21_1) in
    {54}let k21_1: bitstring = encap_k(ek1_1,r21) in
    {44}let dk2: bitstring = dk(ek2_1) in
    {51}let k12_1: bitstring = decaps(dk2,c12_1) in
    {57}let ke2e_1: bitstring = KDF(k12_1,k21_1,th_1) in
    {59}let expI: bitstring = mac(ke2e_1,H(tag(th_1,KCI))) in
    {60}if (kcI_1 = expI) then
    {61}let kcR_1: bitstring = mac(ke2e_1,H(tag(th_1,KCR))) in
    {62}out(net, M6(kcR_1));
    {63}event session_key(ke2e_1);
    {64}event c2_end(id1_1,id2_1,n1_1,n2_1,ek1_1,ek2_1,ke2e_1)
)

-- Query inj-event(c1_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c2_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query inj-event(c1_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c2_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2))
goal reachable: b-event(@p_act(@occ58[],M5(mac(KDF(encap_k(ek2_2,r12_1),encap_k(ek1[],r21_1),TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1))),H(tag(TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1)),KCI[])))))) && b-event(@p_act(@occ50[],M3(encap_c(ek2_2,r12_1)))) && b-inj-event(c2_auth(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2),@occ49_1) -> inj-event(c1_end(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,KDF(encap_k(ek2_2,r12_1),encap_k(ek1[],r21_1),TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1)))),@occ34_1)
The 1st, 2nd, 3rd hypotheses occur strictly before the conclusion.
Abbreviations:
n2_2 = n2_1[sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
ek2_2 = ek2_1[sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
r12_1 = r12[sig2 = sign(skD2[],H(B2(CTX[],RESP[],ID1[],ID2[],n1[],n2_2,ek1[],ek2_2))),ek2 = ek2_2,n2 = n2_2,n1r = n1[],id2r = ID2[],id1r = ID1[]]
r21_1 = r21[c12_1 = encap_c(ek2_2,r12_1),sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
@occ34_1 = @occ34[kcR = mac(KDF(encap_k(ek2_2,r12_1),encap_k(ek1[],r21_1),TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1))),H(tag(TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1)),KCR[]))),c21 = encap_c(ek1[],r21_1),sig2 = sign(skD2[],H(B2(CTX[],RESP[],ID1[],ID2[],n1[],n2_2,ek1[],ek2_2))),ek2 = ek2_2,n2 = n2_2,n1r = n1[],id2r = ID2[],id1r = ID1[]]
@occ49_1 = @occ49[sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
RESULT inj-event(c1_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c2_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2)) is true.
-- Query inj-event(c2_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c1_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query inj-event(c2_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c1_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2))
goal reachable: b-event(@p_act(@occ24[],M4(encap_c(ek1[],r21_1)))) && b-inj-event(c1_auth(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2),@occ19_1) -> inj-event(c2_end(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,KDF(encap_k(ek2_2,r12_1),encap_k(ek1[],r21_1),TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1)))),@occ64_1)
The 1st, 2nd hypotheses occur strictly before the conclusion.
Abbreviations:
n2_2 = n2_1[sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
ek2_2 = ek2_1[sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
r12_1 = r12[sig2 = sign(skD2[],H(B2(CTX[],RESP[],ID1[],ID2[],n1[],n2_2,ek1[],ek2_2))),ek2 = ek2_2,n2 = n2_2,n1r = n1[],id2r = ID2[],id1r = ID1[]]
r21_1 = r21[c12_1 = encap_c(ek2_2,r12_1),sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
@occ64_1 = @occ64[kcI_1 = mac(KDF(encap_k(ek2_2,r12_1),encap_k(ek1[],r21_1),TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1))),H(tag(TH(ID1[],ID2[],n1[],n2_2,ek1[],ek2_2,encap_c(ek2_2,r12_1),encap_c(ek1[],r21_1)),KCI[]))),c12_1 = encap_c(ek2_2,r12_1),sig1_1 = sign(skD1[],H(B1(CTX[],INIT[],ID1[],ID2[],n1[],ek1[]))),ek1_1 = ek1[],n1_1 = n1[],id2r_1 = ID2[],id1r_1 = ID1[]]
@occ19_1 = @occ19[sig2 = sign(skD2[],H(B2(CTX[],RESP[],ID1[],ID2[],n1[],n2_2,ek1[],ek2_2))),ek2 = ek2_2,n2 = n2_2,n1r = n1[],id2r = ID2[],id1r = ID1[]]
RESULT inj-event(c2_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c1_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2)) is true.
-- Query not (event(session_key(k)) && attacker(k)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(session_key(k)) && attacker(k))
RESULT not (event(session_key(k)) && attacker(k)) is true.

--------------------------------------------------------------
Verification summary:

Query inj-event(c1_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c2_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2)) is true.

Query inj-event(c2_end(x_1,y,n1_2,n2_2,ek1_2,ek2_2,k)) ==> inj-event(c1_auth(x_1,y,n1_2,n2_2,ek1_2,ek2_2)) is true.

Query not (event(session_key(k)) && attacker(k)) is true.

--------------------------------------------------------------
